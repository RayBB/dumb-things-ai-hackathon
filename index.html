<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BluQuirks Aquarium</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  *{margin:0;padding:0;overflow:hidden;}
  body{background:#000;}
  canvas{display:block;position:absolute;top:0;left:0;}
  #bg{z-index:1;}
  #fg{z-index:2;}
  #ui{
    position:absolute;top:20px;right:20px;z-index:10;
    color:#66ccff;font-family:Arial,Helvetica,sans-serif;
    pointer-events:auto;
  }

</style>
</head>
<body>

<canvas id="bg"></canvas>
<canvas id="fg"></canvas>

<div id="ui"></div>

<audio src="sound/scizzie.mp3" autoplay></audio>

<script>
/* ---------- CANVASES ---------- */
const bg = document.getElementById('bg'), bgCtx = bg.getContext('2d');
const fg = document.getElementById('fg'), fgCtx = fg.getContext('2d');

function resize(){
  bg.width = fg.width = window.innerWidth;
  bg.height = fg.height = window.innerHeight;
}
window.addEventListener('resize',resize); resize();

/* ---------- BACKGROUND (ocean) ---------- */
const particles=[],rays=[],jellies=[];
for(let i=0;i<100;i++) particles.push({x:Math.random()*bg.width,y:Math.random()*bg.height,
  vx:(Math.random()-0.5)*0.4,vy:Math.random()*0.6+0.2,r:Math.random()*1.8+0.8,a:Math.random()*0.6+0.3});
for(let i=0;i<7;i++) rays.push({x:Math.random()*bg.width,s:Math.random()*0.6+0.4});
for(let i=0;i<5;i++) jellies.push({x:Math.random()*bg.width,y:bg.height+120,
  r:Math.random()*70+50,s:Math.random()*0.5+0.3,p:Math.random()*0.02});

let t=0;
function drawBG(){
  t++; const w=bg.width,h=bg.height;

  // gradient
  const g=bgCtx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#001833'); g.addColorStop(0.5,'#002850'); g.addColorStop(1,'#000d1a');
  bgCtx.fillStyle=g; bgCtx.fillRect(0,0,w,h);

  // depth fog
  for(let y=0;y<h;y+=120){
    const a=(y/h)*0.7;
    bgCtx.fillStyle=`rgba(0,15,40,${a})`;
    bgCtx.fillRect(0,y,w,100);
  }

  // light rays
  rays.forEach(r=>{ r.x-=r.s; if(r.x<-400) r.x=w+400;
    const gr=bgCtx.createLinearGradient(r.x,0,r.x+500,h);
    gr.addColorStop(0,'rgba(120,220,255,.2)'); gr.addColorStop(1,'rgba(80,160,255,0)');
    bgCtx.fillStyle=gr; bgCtx.beginPath();
    bgCtx.moveTo(r.x,0); bgCtx.lineTo(r.x+500,0);
    bgCtx.lineTo(r.x+350,h); bgCtx.lineTo(r.x-150,h);
    bgCtx.closePath(); bgCtx.fill();
  });

  // plankton
  particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy;
    if(p.y>h){p.y=-20; p.x=Math.random()*w;}
    bgCtx.fillStyle=`rgba(160,240,255,${p.a})`;
    bgCtx.beginPath(); bgCtx.arc(p.x,p.y,p.r,0,Math.PI*2); bgCtx.fill();
  });

  // jellyfish
  jellies.forEach(j=>{ j.y-=j.s;
    if(j.y<-200){j.y=h+150; j.x=Math.random()*w;}
    const pulse=Math.sin(t*j.p)*0.4+1;
    const gj=bgCtx.createRadialGradient(j.x,j.y,0,j.x,j.y,j.r*pulse);
    gj.addColorStop(0,'rgba(120,220,255,.35)');
    gj.addColorStop(0.7,'rgba(90,180,255,.15)');
    gj.addColorStop(1,'rgba(60,120,220,0)');
    bgCtx.fillStyle=gj; bgCtx.beginPath();
    bgCtx.arc(j.x,j.y,j.r*pulse,0,Math.PI*2); bgCtx.fill();
  });

  requestAnimationFrame(drawBG);
}
drawBG();

/* ---------- VEHICLE CONFIGS AND LOADING ---------- */
const vehicleConfigs = [
  { imgSrc: '/img/fish.png', w: 110, h: 70, speedMin: 1.2, speedMax: 3.0, count: 2, facingLeft: false, spawnProb: 1 },
  { imgSrc: '/img/pelican.png', w: 110, h: 70, speedMin: 1.2, speedMax: 3.0, count: 5, facingLeft: true, spawnProb: 1 },
  { imgSrc: '/img/muni.png', w: 180, h: 120, speedMin: 0.6, speedMax: 1.4, count: 4, facingLeft: true, spawnProb: 1 },
  { imgSrc: '/img/waymo.png', w: 180, h: 120, speedMin: 0.6, speedMax: 1.4, count: 3, facingLeft: true, spawnProb: 1 },
  { imgSrc: '/img/sealion.png', w: 90, h: 60, speedMin: 0.3, speedMax: 0.7, count: 1, facingLeft: false, spawnProb: 0.12 },
  { imgSrc: '/img/fog.png', w: 200, h: 140, speedMin: 0.3, speedMax: 0.7, count: 1, facingLeft: false, spawnProb: 0.1 },
  { imgSrc: '/img/sourdough.png', w: 120, h: 120, speedMin: 0.5, speedMax: 0.9, count: 1, facingLeft: false, spawnProb: 1 },
  { imgSrc: '/img/cable_car.png', w: 180, h: 120, speedMin: 0.5, speedMax: 1.3, count: 2, facingLeft: false, spawnProb: 1 },
  { imgSrc: '/img/ai_billboard.png', w: 300, h: 180, speedMin: 0.2, speedMax: 0.5, count: 1, facingLeft: false, spawnProb: 0.05 },
  { imgSrc: '/img/transamerica.png', w: 180, h: 300, speedMin: 0.1, speedMax: 0.2, count: 1, facingLeft: false, spawnProb: 0.02 },
  { imgSrc: '/img/lacroix.png', w: 50, h: 80, speedMin: 0.6, speedMax: 1.4, count: 3, facingLeft: true, spawnProb: 1 },
  { imgSrc: '/img/goldengate.png', w: 400, h: 200, speedMin: 0.05, speedMax: 0.1, count: 1, facingLeft: false, spawnProb: 0.03 },
  { imgSrc: '/img/clipper.png', w: 180, h: 100, speedMin: 1.0, speedMax: 2.0, count: 2, facingLeft: false, spawnProb: 1 },
  { imgSrc: '/img/coyote.png', w: 100, h: 80, speedMin: 0.8, speedMax: 1.6, count: 1, facingLeft: true, spawnProb: 0.5 },
  { imgSrc: '/img/ia.png', w: 120, h: 80, speedMin: 0.8, speedMax: 1.6, count: 1, facingLeft: true, spawnProb: 0.5 },
];

const vehicleTypes = [];
let loadedImages = 0;

function createVehicle(type) {
  const config = type.config;
  const fromLeft = Math.random() > 0.5;
  type.vehicles.push({
    x: fromLeft ? -300 : fg.width + 300,
    y: Math.random() * (fg.height * 0.7) + 100,
    vx: (fromLeft ? 1 : -1) * (Math.random() * (config.speedMax - config.speedMin) + config.speedMin),
    w: config.w, h: config.h,
    flip: config.facingLeft ? fromLeft : !fromLeft,
    bob: Math.random() * 0.04
  });
}

vehicleConfigs.forEach(config => {
  const img = new Image();
  img.src = config.imgSrc;
  const vehicles = [];
  img.onload = () => {
    tintBlue(img, () => {
      // Spawn initial vehicles if spawnProb >=1 (always spawn mode)
      if (config.spawnProb >= 1) {
        for(let i=0; i<config.count; i++){
          createVehicle({config, vehicles});
        }
      }
      loadedImages++;
      if (loadedImages === vehicleConfigs.length) {
        // All images loaded, ensure drawFG is running if not started yet
        drawFG();
      }
    });
  };
  vehicleTypes.push({ img, vehicles, config });
});

// Start drawFG preemptively with first loaded (fish), but others will populate
if (vehicleTypes[0].img.complete) drawFG(); // But since onload starts it, ok

/* ---------- BUBBLES ---------- */
const bubbles=[];
for(let i=0;i<30;i++){
  bubbles.push({
    x:Math.random()*fg.width,
    y:fg.height+Math.random()*150,
    r:Math.random()*6+4,
    s:Math.random()*2+1,
    sway:Math.random()*0.04
  });
}

/* ---------- FOREGROUND (fish + bubbles + quirk) ---------- */
function tintBlue(img, callback) {
  const canvas = document.createElement('canvas');
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imgData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
    if (a > 0) {
      data[i] = Math.min(255, r * 0.8);
      data[i + 1] = Math.min(255, g * 0.8);
      data[i + 2] = Math.min(255, b * 1.2);
    }
  }
  ctx.putImageData(imgData, 0, 0);
  const originalSrc = img.src;
  img.src = canvas.toDataURL();
  img.onload = () => {
    if (callback) callback(img);
  };
}

function drawFG(){
  fgCtx.clearRect(0,0,fg.width,fg.height);
  t++;

  // ----- BUBBLES -----
  bubbles.forEach(b=>{
    b.y-=b.s; b.x+=Math.sin(t*b.sway)*0.6;
    if(b.y<-30){b.y=fg.height+30; b.x=Math.random()*fg.width;}
    fgCtx.fillStyle='rgba(220,245,255,.7)';
    fgCtx.beginPath(); fgCtx.arc(b.x,b.y,b.r,0,Math.PI*2); fgCtx.fill();
    fgCtx.fillStyle='rgba(255,255,255,.9)';
    fgCtx.beginPath(); fgCtx.arc(b.x-b.r*0.4,b.y-b.r*0.4,b.r*0.3,0,Math.PI*2); fgCtx.fill();
  });

  // ----- SPAWN VEHICLES ------
  vehicleTypes.forEach(type => {
    if (type.config.spawnProb > 0 && Math.random() < type.config.spawnProb && type.vehicles.length < type.config.count) {
      createVehicle(type);
    }
  });

  // ----- VEHICLES -----
  vehicleTypes.forEach(type => {
    type.vehicles.forEach(v => {
      v.x += v.vx;
      v.y += Math.sin(t * v.bob) * 0.7;

      if (v.x < -350 || v.x > fg.width + 350) {
        v.vx *= -1;
        v.flip = !v.flip;
      }

      fgCtx.save();
      fgCtx.translate(v.x, v.y);
      if (v.flip) fgCtx.scale(-1, 1);
      fgCtx.drawImage(type.img, -v.w / 2, -v.h / 2, v.w, v.h);
      fgCtx.restore();
    });
  });

  requestAnimationFrame(drawFG);
}

</script>
</body>
</html>
