<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BluQuirks Aquarium</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  *{margin:0;padding:0;overflow:hidden;}
  body{background:#000;}
  canvas{display:block;position:absolute;top:0;left:0;}
  #bg{z-index:1;}
  #fg{z-index:2;}
  #ui{
    position:absolute;top:20px;right:20px;z-index:10;
    color:#66ccff;font-family:Arial,Helvetica,sans-serif;
    pointer-events:auto;
  }
  #startAudio{
    position:fixed;top:50%;left:50%;
    --sway: 0;
    --bob: 0;
    transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(0deg) scale(1);
    z-index:100;color:#ffffff;font-family:Arial,Helvetica,sans-serif;
    font-size:24px;padding:20px;border:2px solid #66ccff;
    background:rgb(0, 195, 255);border-radius:10px;cursor:pointer;
    pointer-events:auto;
  }

  @keyframes buttonChaos {
    0% { transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(0deg) scale(1); box-shadow: 0 0 20px #66ccff; }
    25% { transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(2deg) scale(1.05); box-shadow: 0 0 30px #44aaff; }
    50% { transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(-2deg) scale(1); box-shadow: 0 0 25px #77ddff; }
    75% { transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(1deg) scale(1.03); box-shadow: 0 0 35px #55bbff; }
    100% { transform: translate(calc(-50% + var(--sway)), calc(-50% + var(--bob))) rotate(0deg) scale(1.02); box-shadow: 0 0 20px #66ccff; }
  }

  #startAudio.animated {
    animation: buttonChaos 3s ease-in-out infinite;
  }

</style>
</head>
<body>

<canvas id="bg"></canvas>
<canvas id="fg"></canvas>

<div id="ui"></div>

<div id="startAudio">ðŸŒŠ Tap to Start ðŸŒ‰</div>

<audio src="sound/scizzie.mp3" loop></audio>

<script>
/* ---------- AUDIO ---------- */
const audio = document.querySelector('audio');
let audioStarted = false;

/* ---------- START AUDIO BUTTON ---------- */
const startAudioBtn = document.getElementById('startAudio');
startAudioBtn.addEventListener('click', () => {
  if (!audioStarted) {
    audio.play().catch(err => {
      console.log('Audio play failed:', err);
    });
    audioStarted = true;
    startAudioBtn.style.display = 'none';
    // Start spawning initial vehicles when audio starts
    spawnInitialVehicles();
  }
});

/* ---------- CANVASES ---------- */
const bg = document.getElementById('bg'), bgCtx = bg.getContext('2d');
const fg = document.getElementById('fg'), fgCtx = fg.getContext('2d');

function resize(){
  bg.width = fg.width = window.innerWidth;
  bg.height = fg.height = window.innerHeight;
}
window.addEventListener('resize',resize); resize();

/* ---------- BACKGROUND (ocean) ---------- */
const particles=[],rays=[],jellies=[];
// more plankton for chaos
for(let i=0;i<300;i++) particles.push({x:Math.random()*bg.width,y:Math.random()*bg.height,
  vx:(Math.random()-0.5)*0.6,vy:Math.random()*0.8+0.3,r:Math.random()*2.5+1,a:Math.random()*0.8+0.4,
  sway:Math.random()*0.05+0.02});
// more rays
for(let i=0;i<12;i++) rays.push({x:Math.random()*bg.width,s:Math.random()*0.8+0.5});
// more jellies
for(let i=0;i<10;i++) jellies.push({x:Math.random()*bg.width,y:bg.height+120,
  r:Math.random()*90+60,s:Math.random()*0.7+0.4,p:Math.random()*0.03});

let t=0;
function drawBG(){
  t++; const w=bg.width,h=bg.height;

  // Animate the start audio button with chaotic ocean motion
  if (startAudioBtn && startAudioBtn.style.display !== 'none') {
    const buttonSway = Math.sin(t * 0.02) * 15; // horizontal sway
    const buttonBob = Math.sin(t * 0.03) * 10; // vertical bobbing
    startAudioBtn.style.setProperty('--sway', `${buttonSway}px`);
    startAudioBtn.style.setProperty('--bob', `${buttonBob}px`);
    if (!startAudioBtn.classList.contains('animated')) {
      startAudioBtn.classList.add('animated');
    }
  }

  // gradient - brighter blues
  const g=bgCtx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#004466'); g.addColorStop(0.5,'#0099cc'); g.addColorStop(1,'#003355');
  bgCtx.fillStyle=g; bgCtx.fillRect(0,0,w,h);

  // light rays
  rays.forEach(r=>{ r.x-=r.s; if(r.x<-400) r.x=w+400;
    const gr=bgCtx.createLinearGradient(r.x,0,r.x+500,h);
    gr.addColorStop(0,'rgba(120,220,255,.2)'); gr.addColorStop(1,'rgba(80,160,255,0)');
    bgCtx.fillStyle=gr; bgCtx.beginPath();
    bgCtx.moveTo(r.x,0); bgCtx.lineTo(r.x+500,0);
    bgCtx.lineTo(r.x+350,h); bgCtx.lineTo(r.x-150,h);
    bgCtx.closePath(); bgCtx.fill();
  });

  // plankton - brighter blue with chaotic sway
  particles.forEach(p=>{ p.x+=p.vx + Math.sin(t*p.sway)*1.2; p.y+=p.vy;
    if(p.y>h){p.y=-20; p.x=Math.random()*w;}
    bgCtx.fillStyle=`rgba(100,220,255,${p.a})`;
    bgCtx.beginPath(); bgCtx.arc(p.x,p.y,p.r,0,Math.PI*2); bgCtx.fill();
  });

  // jellyfish - brighter blues
  jellies.forEach(j=>{ j.y-=j.s;
    if(j.y<-200){j.y=h+150; j.x=Math.random()*w;}
    const pulse=Math.sin(t*j.p)*0.4+1;
    const gj=bgCtx.createRadialGradient(j.x,j.y,0,j.x,j.y,j.r*pulse);
    gj.addColorStop(0,'rgba(100,230,255,.5)');
    gj.addColorStop(0.7,'rgba(80,200,255,.25)');
    gj.addColorStop(1,'rgba(50,140,255,0)');
    bgCtx.fillStyle=gj; bgCtx.beginPath();
    bgCtx.arc(j.x,j.y,j.r*pulse,0,Math.PI*2); bgCtx.fill();
  });

  requestAnimationFrame(drawBG);
}
drawBG();

/* ---------- TECH BRO QUOTES ---------- */
const techBroQuotes = {
  // Available for expansion - add arrays for any vehicle
  // fish: [],
  // pelican: [],
  // muni: [],
  waymo: [
    "Yo the app says my ride is 2 minutes away but you're not even moving!",
    "Waymo? I'm driving Teslas through tunnels at 100mph with my eyes closed.",
    "Self-driving? I built my own neural network for traffic prediction.",
    "Automated driving lacks the human intuition for gap-finding in SF traffic.",
    "Waymo payment integration should use crypto for micropayments.",
    "Why isn't Waymo integrated with SuperShuttle and organized carpools?",
    "Driverless cars need better algorithms for SF's erratic pedestrians.",
    "I'd invest in the company doing high-speed autonomous bicycle couriers instead."
  ],
  // sealion: [],
  fog: [
    "Fog? Just blockchain weather prediction to optimize my morning commute."
  ],
  // sourdough: [],
  cablecar: [
    "Cable cars are so inefficient! Why not automate with drone taxis?",
    "Public transit should use hyperloops for zero-emission travel.",
    "Cable cars need RFID tracking and dynamic pricing algorithms.",
    "I'd invest in the app doing algorithmic cable car wait time prediction.",
    "SF infrastructure is stuck in the 1800s! We need maglev transportation."
  ],
  // ai_billboard: [],
  transamerica: [
    "That pyramid would look way better with LED smart glass and AR integration."
  ],
  lacroix: [
    "Dude, all the Pamplemousse ran out? This is a supply chain FAILURE!",
    "La Croix? I optimized my hydration with electrolyte-infused smart water instead.",
    "This flavor doesn't pair with my keto intermittent fasting regimen.",
    "Not sustainable enough. Where's the recycled aluminum zero-waste alternative?",
    "La Croix? Basic. I craft my own kombucha from biodynamic grapes in Napa.",
    "Cherry Lime? Lame. The biohacker in me demands adaptogenic mushrooms.",
    "This isn't the lime flavor? WHY IS THE UX SO POOR?",
    "I invested in the startup making premium sparkling water pods last week.",
    "Limiting to 12 flavors? Not user-centric design thinking.",
    "La Croix contains aspartame? That's a dealbreaker for my clean eating journey!"
  ],
  goldengate: [
    "The Golden Gate should have smart sensors for real-time structural monitoring.",
    "Why isn't the bridge powered by tidal energy and LED display advertising?",
    "Bridge tolls need dynamic pricing based on traffic flow algorithms."
  ],
  // clipper: [],
  // coyote: [],
  // ia: []
};

/* ---------- VEHICLE SPAWNING ---------- */
function spawnInitialVehicles() {
  // Spawn initial vehicles for all vehicle types that should always spawn (spawnProb >= 1)
  vehicleTypes.forEach(type => {
    if (type.config.spawnProb >= 1) {
      for(let i = 0; i < type.config.count; i++){
        createVehicle(type);
      }
    }
  });
}

/* ---------- VEHICLE CONFIGS AND LOADING ---------- */
const vehicleConfigs = [
  { imgSrc: 'img/fish.png', w: 110, h: 70, speedMin: 1.2, speedMax: 3.0, count: 2, facingLeft: false, spawnProb: 1, name: 'fish' },
  { imgSrc: 'img/pelican.png', w: 110, h: 70, speedMin: 1.2, speedMax: 3.0, count: 5, facingLeft: true, spawnProb: 1, name: 'pelican' },
  { imgSrc: 'img/muni.png', w: 180, h: 120, speedMin: 0.6, speedMax: 1.4, count: 4, facingLeft: true, spawnProb: 1, name: 'muni' },
  { imgSrc: 'img/waymo.png', w: 200, h: 120, speedMin: 0.6, speedMax: 1.4, count: 3, facingLeft: true, spawnProb: 1, name: 'waymo' },
  { imgSrc: 'img/sealion.png', w: 90, h: 60, speedMin: 0.3, speedMax: 0.7, count: 1, facingLeft: false, spawnProb: 0.12, name: 'sealion' },
  { imgSrc: 'img/fog.png', w: 200, h: 140, speedMin: 0.3, speedMax: 0.7, count: 1, facingLeft: false, spawnProb: 0.1, name: 'fog' },
  { imgSrc: 'img/sourdough.png', w: 120, h: 120, speedMin: 0.5, speedMax: 0.9, count: 1, facingLeft: false, spawnProb: 1, name: 'sourdough' },
  { imgSrc: 'img/cable_car.png', w: 180, h: 120, speedMin: 0.5, speedMax: 1.3, count: 2, facingLeft: false, spawnProb: 1, name: 'cablecar' },
  { imgSrc: 'img/ai_billboard.png', w: 300, h: 180, speedMin: 0.2, speedMax: 0.5, count: 1, facingLeft: false, spawnProb: 0.05, name: 'ai_billboard' },
  { imgSrc: 'img/transamerica.png', w: 180, h: 300, speedMin: 0.1, speedMax: 0.2, count: 1, facingLeft: false, spawnProb: 0.02, name: 'transamerica' },
  { imgSrc: 'img/lacroix.png', w: 50, h: 80, speedMin: 0.6, speedMax: 1.4, count: 3, facingLeft: true, spawnProb: 1, name: 'lacroix' },
  { imgSrc: 'img/goldengate.png', w: 400, h: 200, speedMin: 0.05, speedMax: 0.1, count: 1, facingLeft: false, spawnProb: 0.03, name: 'goldengate' },
  { imgSrc: 'img/clipper.png', w: 180, h: 100, speedMin: 1.0, speedMax: 2.0, count: 2, facingLeft: false, spawnProb: 1, name: 'clipper' },
  { imgSrc: 'img/coyote.png', w: 100, h: 80, speedMin: 0.8, speedMax: 1.6, count: 1, facingLeft: true, spawnProb: 0.5, name: 'coyote' },
  { imgSrc: 'img/ia.png', w: 120, h: 80, speedMin: 0.8, speedMax: 1.6, count: 1, facingLeft: true, spawnProb: 0.5, name: 'ia' },
];

const vehicleTypes = [];
let loadedImages = 0;

function createVehicle(type) {
  const config = type.config;
  const fromLeft = Math.random() > 0.5;
  type.vehicles.push({
    x: fromLeft ? -300 : fg.width + 300,
    y: Math.random() * (fg.height * 0.7) + 100,
    vx: (fromLeft ? 1 : -1) * (Math.random() * (config.speedMax - config.speedMin) + config.speedMin),
    w: config.w, h: config.h,
    flip: config.facingLeft ? fromLeft : !fromLeft,
    bob: Math.random() * 0.04
  });
}

vehicleConfigs.forEach(config => {
  const img = new Image();
  img.src = config.imgSrc;
  const vehicles = [];
  img.onload = () => {
    tintBlue(img, () => {
      loadedImages++;
      if (loadedImages === vehicleConfigs.length) {
        // All images loaded, ensure drawFG is running if not started yet
        drawFG();
      }
    });
  };
  vehicleTypes.push({ img, vehicles, config });
});

// Start drawFG preemptively with first loaded (fish), but others will populate
if (vehicleTypes[0].img.complete) drawFG(); // But since onload starts it, ok

/* ---------- BUBBLES ---------- */
const bubbles=[];
// more bubbles for aquatic chaos
for(let i=0;i<60;i++){
  bubbles.push({
    x:Math.random()*fg.width,
    y:fg.height+Math.random()*150,
    r:Math.random()*6+4,
    s:Math.random()*2+1,
    sway:Math.random()*0.04
  });
}

/* ---------- FOREGROUND (fish + bubbles + quirk) ---------- */
function tintBlue(img, callback) {
  const canvas = document.createElement('canvas');
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imgData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
    if (a > 0) {
      data[i] = Math.min(255, r * 0.8);
      data[i + 1] = Math.min(255, g * 0.8);
      data[i + 2] = Math.min(255, b * 1.2);
    }
  }
  ctx.putImageData(imgData, 0, 0);
  const originalSrc = img.src;
  img.src = canvas.toDataURL();
  img.onload = () => {
    if (callback) callback(img);
  };
}

function drawFG(){
  fgCtx.clearRect(0,0,fg.width,fg.height);
  t++;

  // ----- BUBBLES ----- brighter blue aquatic
  bubbles.forEach(b=>{
    b.y-=b.s; b.x+=Math.sin(t*b.sway)*0.8;
    if(b.y<-30){b.y=fg.height+30; b.x=Math.random()*fg.width;}
    fgCtx.fillStyle='rgba(180,240,255,.8)';
    fgCtx.beginPath(); fgCtx.arc(b.x,b.y,b.r,0,Math.PI*2); fgCtx.fill();
    fgCtx.fillStyle='rgba(220,255,255,.9)';
    fgCtx.beginPath(); fgCtx.arc(b.x-b.r*0.4,b.y-b.r*0.4,b.r*0.3,0,Math.PI*2); fgCtx.fill();
  });

  // ----- SPAWN VEHICLES ------
  // Only spawn probabilistic vehicles after audio has started
  if (audioStarted) {
    vehicleTypes.forEach(type => {
      if (type.config.spawnProb < 1 && Math.random() < type.config.spawnProb && type.vehicles.length < type.config.count) {
        createVehicle(type);
      }
    });
  }

  // ----- VEHICLES -----
  vehicleTypes.forEach(type => {
    type.vehicles.forEach(v => {
      v.x += v.vx;
      v.y += Math.sin(t * v.bob) * 0.7;

      if (v.x < -350 || v.x > fg.width + 350) {
        v.vx *= -1;
        v.flip = !v.flip;
      }

      fgCtx.save();
      fgCtx.translate(v.x, v.y);
      if (v.flip) fgCtx.scale(-1, 1);
      fgCtx.drawImage(type.img, -v.w / 2, -v.h / 2, v.w, v.h);
      fgCtx.restore();
    });
  });

  requestAnimationFrame(drawFG);
}

// Click handling for sassy tech bro quotes
fg.addEventListener('click', (e) => {
  const rect = fg.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Check all vehicle types for clickable vehicles with quotes
  for (const vehicleType of vehicleTypes) {
    const config = vehicleType.config;
    const quotes = techBroQuotes[config.name];
    if (!quotes || quotes.length === 0) continue; // Skip if no quotes

    const clickedVehicle = vehicleType.vehicles.find(vehicle => {
      const left = vehicle.x - vehicle.w / 2;
      const right = vehicle.x + vehicle.w / 2;
      const top = vehicle.y - vehicle.h / 2;
      const bottom = vehicle.y + vehicle.h / 2;

      return clickX >= left && clickX <= right && clickY >= top && clickY <= bottom;
    });

    if (clickedVehicle) {
      // Show random quote from this vehicle's quote array
      const ui = document.getElementById('ui');
      const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
      ui.innerHTML = `<div style="background:rgba(0,0,0,0.8);padding:10px;border-radius:5px;max-width:250px;">"${randomQuote}"</div>`;
      ui.style.display = 'block';

      // Hide quote after 3 seconds
      setTimeout(() => {
        ui.style.display = 'none';
      }, 5000);
      break; // Only show one quote per click
    }
  }
});

</script>
</body>
</html>
